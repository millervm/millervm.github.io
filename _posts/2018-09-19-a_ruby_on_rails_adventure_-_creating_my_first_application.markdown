---
layout: post
title:      "A Ruby on Rails Adventure - Creating my First Application"
date:       2018-09-19 21:50:01 +0000
permalink:  a_ruby_on_rails_adventure_-_creating_my_first_application
---


Completing the Rails portfolio project in the Full-Stack Web Development curriculum is another very important step in the program. Not only does it represent the 75% mark, meaning students are heading into the final stretch of the curriculum once they wrap up the Rails unit, but the project itself offers students a chance to design, code, and share their own fully-functional Rails application. Given that there are entire websites using the Ruby on Rails framework, I feel proud knowing that I have now created my own Rails application, even if it is a rather simple example.

Building on the concepts that we covered in the Sinatra section, which we finished by creating our own content management system, the Rails project requires students to create a similar system for managing database contents. However, using the Rails framework, many of the smaller details are built into the system. So, we could use Rails generators to cover a lot of the initial setup, such as establishing our models and their attributes, allowing us to focus more on the bigger picture. Using some `rails g <GENERATOR DETAILS>` and `rake db:migrate` commands, I had my database and my model files, which was a good starting point.

Granted, one of the project requirements was that we couldn’t use Rails scaffolding, which would set up the basic structure very quickly, to get started, but I myself wouldn’t have preferred that option, anyway. I prefer to use slightly more fine-tuned options in order to get exactly what I want, and to avoid excess files and folders that would need to be deleted. For me, using migration and model generators was a great way to get the models and database columns established, and then I added controllers and views as needed. For such a small application, the time and effort needed to add the individual controller and view files was minimal, although I can see how that might be tedious for larger applications.
 
The other project requirements included various mandatory features and contents, such as nested resources, displaying errors for form submissions, user authentication, and a third-party login option (via the Omniauth gem, for example). These were all topics covered in the Rails unit, so for me, it was more difficult to decide how to implement the features than to actually code them. For example, should all of my routes be nested, or would that make the URLs and controller actions overly complicated?

Specifically, my application, “Shopping List”, includes the following models: User, List, and Item. The relationships are all essentially `belongs_to` and `has_many`, with a User having many Lists, each of which has many Items. To avoid paths like `/users/:id/lists/:id/items/:id`, I decided to make the “index” routes dependent on the `belongs_to` relationships, and the “new” paths could be either independent or based on nested routes. More instance-specific routes, like for “show” and “edit” actions, are based on only the object itself. For example, the URL for a user’s list index is `/users/:id/lists`, while the URL to display a specific list is `/lists/:id`. No path incorporates all three models at once, and only those that relate directly to a `belongs_to` relationship (and require a specific ID number, such as `:user_id` for a specific set of lists) involve more than one model. There are certainly various approaches to this subject, but I tried to choose one that addressed the nested resources without being overly complicated.

Most of the other required contents were straightforward, and I found them simple enough to code. User authentication involved specific validations defined in the User model as well as the use of `has_secure_password` for password encryption and verification. I chose to use Google for the alternative login option, so I researched that and added the relevant gems and code. Various helper methods were defined in my ApplicationController file, for use throughout the application. For example, `current_user` and `logged_in?` helped to keep my code DRY, similar to several other methods that I included for specific `before_action` steps, such as `require_login`. To further DRY my code, I also created other methods in specific controllers, to avoid repeating the same contents across multiple actions.

Certain other requirements for the project involved model-specific attributes and methods. For my project, these aspects were fairly straightforward. Boolean attributes for List (`:active`) and Item (`:urgent` and `complete`) allowed for the sorting of objects for various types of displays in the views. The more complicated aspects of my code were some of the form-based actions. Specifically, I wanted to allow for user editing (for `:name` and `:password`) such that I could avoid validation errors for `:password` when only `:name` was being edited. Similarly, I encountered double-rendering errors for `lists#create`, `lists#update`, `items#create`, and `items#update` when I tried to include the redirect involving `verify_user` failures. These details required some research, but online resources (particularly the ever-helpful StackOverflow!) helped me add the appropriate contents to my validations and actions to address the issues.

Overall, the details of my application were fairly easy to code, including some aspects that weren’t required, such as specific formatting and layout options, but that I wanted to address anyway. I enjoyed working on the additional parts along with the required portions, as I liked thinking of the overall “design” of my application. I wanted to personalize the appearance, and include a cohesive look more like what a “real” application or website would have.

Aside from the trickier aspects mentioned above, which required troubleshooting and trying to choose the best of multiple options, the full project wasn’t as difficult as I feared. It sounded intimidating at first, but creating a Rails application from scratch was a great experience. Completing the whole project took me much longer than I’d have liked, due to some work and personal issues that ate into some of my coding time, but, piece by piece, I was finally able to finish the project. Eventually, everything was in place, and I’m pleased with the finished product. It may not be an especially complex or exciting application, but it’s complete and functional, and it’s made me more confident in my future as a web developer. 


---
layout: post
title:      "Using Sinatra to Create a Basic CMS, My Way"
date:       2018-01-28 17:35:09 -0500
permalink:  creating_a_basic_cms_using_sinatra_my_way
---


Having completed my first Sinatra application, which provides a CMS (content management system) for tracking a user's "to read" list and is called “Bookcase”, I feel a sense of relief, and more than a little excitement. Using the Ruby code, gems, and other skills and tools that I've learned about so far as a Learn student, I've become a “creator of the internet”. As promised at the beginning of the Rack section in the Learn curriculum, I'm no longer only a user of the internet. Granted, my application is not actually available for use anywhere on the web, but the framework is there, and that’s a significant step towards becoming a web developer.

This project allows students to create their own original content that users can interact with over the internet. For students like me, it’s the first time we’ve done so completely on our own, from beginning to end. The CLI gem project involved similar user-system interaction, but it was missing the “web” element that is essential to web development. This application, though, goes beyond the console, with help from Sinatra and ActiveRecord. The user's details can now be saved and viewed in a future session. The user can log in securely and maintain their own account-specific details. The user can access the application in a web browser and navigate using more than simple text inputs as prompted.

With a standard MVC (model-view-controller) structure, my application is fairly straightforward. It has two different models (User and Book), various views for both models and for general pages (such as the main index/homepage), and a single application controller. I decided against multiple, model-specific controllers because the paths I used were fairly simple, and there was very little overlap between the routes that were required for each of the models. For example, login and signup actions are only applicable to users, and only books can be edited and deleted. 

To distinguish between the “to read” and “have read” books, I decided to give each Book instance a boolean attribute (via ActiveRecord), called “to_read”. The default value assigned when a new Book is added to the database is “true”, meaning the status is “to read”. Essentially, I decided to assume that each book was being added to the “to read” list, but the user could edit it at any time to move it to the “have read” list. This allows for users to add books that they’ve already read, in case they want to track their favorites or read them again, without including the extra step of selecting the status in the creation process. They can easily edit the status if they want to move new books to a different portion of their “bookcase”.

As for the views, most are specific to logged-in users, with redirects for visitors who aren’t logged in or users who are trying to access other users’ details. Each user’s index page and “bookcase” are fairly simple, with the total number of “to read” and “have read” books listed on the index page and the “bookcase” itself listing the books in two sections, based on status (“To Read” and “Have Read”), in alphabetical order by title. Each book’s title is a link to the book’s specific page, which lists the book’s title, author, and status and contains a link to the “edit” page, where the user can change any of the book’s details or select the “Remove from Bookcase” button. There are also various links throughout the application that can help the user navigate more easily.

My code isn’t particularly complicated, but it does exactly what I intended for it to do. I’ve refactored it, I’ve checked and tested each path throughout the application, and I’ve adjusted the layout and formatting so that the design at least somewhat matches my general preferences regarding organization and style. To me, “good” code doesn’t necessarily have to be “complex”, as what matters most is that it functions. I know that there might be room for improvement, but I think my code works well. And for people who might be interested in what the application does, and how it would enable them to track the books they want to read and have read, it could be quite useful.

In addition to the required elements, such as database migrations and manipulation of user content, I was also interested in adding a couple of extra components to my code, for aesthetic purposes. Specifically, I wanted a custom error message for nonexistent pages that was more consistent with the rest of the application than the Sinatra “doesn’t know this ditty” page, which seemed to really interrupt the flow of site navigation when I was testing it myself. So, with help from useful online sources, I discovered that I could accomplish this in my application controller. The simple approach I used was to add the following path in the controller:
	
<code>
not_found do		
&nbsp;&nbsp;&nbsp; erb: error<br>
end
</code>

Then I created a basic view to display the error message. I included a link that directs users back to the main homepage, which is what I really wanted in order to maintain smooth, uninterrupted navigation of the application. Now, trying to access a page that doesn’t exist, such as a book that hasn’t been added to database, results in a much simpler page that provides an easy path back to the rest of the application.

With that accomplished, I realized that there was another aspect of my application that was bothering me: its appearance. Using “Shotgun” to experiment with and test the application, I quickly grew tired of the black text and white background. I knew that some very basic CSS styling would remedy that, but I didn’t know how that might work in a Sinatra application with such different page views and structures than what was covered in the HTML and CSS sections of the curriculum. When I was unable to change the styling using the same methods that worked for those other lessons, I again turned to some online resources (at least one being Stack Overflow). 

After doing some research, I learned that I could include the CSS styling in a “public” folder, which I could reference in my application controller to specify the location. I updated my code to get that all set up, and then went about adding the desired CSS styling options to my “style.css” file. Eventually, I settled on a light brown background, web-safe serif font, and dark grey text. For links (“a” elements), I decided to use the same grey text color, with a lighter option for visited links.

Adding these extra elements didn’t actually take much time, as setting up the paths, views, database, and other core details required much more effort. Also, I’m pleased with the overall look and function of the application, so I think the extra steps were worthwhile. The project took me longer than I’d hoped to complete, but that was due more to other scheduling issues and then having to piece together all the different elements required to complete the project, such as the video walkthrough and this blog post. Having everything finished is very satisfying, though, and I enjoyed working on the project. My understanding of the course content improved with even more hands-on experience and the chance to write my own unique code, and completing my application means that I’m one step closer to becoming a web developer. Transorming into a "creator of the web" has become a reality.
